#생성자

>생성자메서드의 특징

    메서드의 리턴타입이 없다.

   메서드의 이름은 클래스의 이름과 동일하다.

    new생성자가 메모리를 생성한 직후 호출 되어진다.


즉, 메소드 이름이 클래스명과 똑같고, void나 int 처럼 반환형이 선언되어 있지도 않고 , return 반환을 하지도 않는다. 입력만 있을 뿐 출력은 없다.

 초기화만 해주는 것이다.







##new 클래스명

이러한 명령어는 "인스턴스의 생성"을 뜻한다. 걍 생성을 한다는 거다.





#상속


>자바에서도 부모클래스(parent class)로부터 상속받은 자식클래스(children class)는 부모클래스의 모든 자원과 메서드 등을 자신의 것 처럼 사용 할 수 있습니다.

>하나의 부모 클래스(parent class)는 여러개의 자식 클래스(children)을 가질 수 있습니다.
반대로 하나의 클래스는 여러개의 클래스로부터 상속을 받을수는 없습니다.
부모 클래스(parent class)로부터 상속받은 자식 클래스는 부모 클래스의 자원(source) 모두를 사용 할 수 있습니다.
반대로 부모클래스는 자식클래스의 자원을 가져다 쓸 수는 없습니다.
자식클래스는 또다른 클래스의 부모 클래스가 될 수 있습니다.
자식클래스는 부모클래스로부터 물려받은 자원을 override 하여 수정해서 사용 할 수 있습니다.




##super

super() 는 자신의 부모클래스의 생성자를 호출하는 녀석입니다. 바로 윗단계의 부모클래스 뿐아니라 부모의 부모 또 그 부모의 부모 클래스의 생성자를 모두 호출합니다.

● 부모 클래스의 멤버 변수 접근: super.멤버변수

● 부모 클래스의 멤버 메소드 접근: super.멤버메소드(매개변수);

● 부모 클래스의 생성자 호출: super(매개변수);






#overriding

>부모에게서 물려받은 자원을 그대로 사용해도 되지만, 조금 변형시켜 사용하고자 할 때 자원을 override 하여 사용합니다

자식 클래스에서 메소드를 재정의 하고 싶을때 재정의 될 부모 클래스의 메소드에 사용되며, override 키워드는 부모 클래스 내에서 선언된 메소드를 재정의 하겠다는 표시를 하는 것과 같습니다.




#overloading
>클래스에 같은 이름이지만 매개 변수가 다른 여러 메소드가있는 경우이를 메소드 오버로드라고 합니다.
서로 다른 유형의 여러 함수가 같은 이름으로 정의

>java에서 메소드를 오버로드하는 방법에는 두 가지가 있습니다.
1. 인수의 수를 변경함으로써
2. 데이터 유형 변경






#인터페이스

● 추상 클래스는 일반 메소드와 추상 메소드를 둘다 가질 수 있는 반면에, 인터페이스는 오로지 추상 메소드와 상수만을 가집니다. 즉 로직을 작성할 수 없습니다.

● 인터페이스 내에 존재하는 메소드는 무조건 public abstract로 선언됩니다.

● 인터페이스 내에 존재하는 변수는 무조건 public static final로 선언됩니다.

● 인터페이스는 다중 상속과 비슷한 기능을 제공합니다.


>인터페이스는 단일 상속만 가능한 클래스와는 달리 다중 상속이 가능합니다.
. 우리가 만약 프로젝트를 진행하고 있는데, 인터페이스를 사용하면 다른 구성원들이 각각의 부분을 완성할때 까지 기다리지 않고 서로간의 규약만 정해두어 내 부분만 따로 나눠서 작성된 코드를 컴파일 할 수 있습니다.







#set, get 접근자

>메소드와 같이 객체가 가지고 있는 것들을 외부에서 접근하지 못하도록 숨기는 것을 말합니다.
다른 이유는 안정성을 위한 것입니다. 객체 내부에서만 사용되는 필드나 메소드는 외부로 공개하면, 외부에서 이를 수정할 수 있기 때문에 안정성이 깨질 우려가 있기 때문입니다.
get 접근자만 존재한다면 읽을 수만 있으며, set 접근자만 존재하면 쓸 수만 있으며, 두 접근자가 모두 존재하면 읽을 수도 있고, 쓸 수도 있게 됩니다.
